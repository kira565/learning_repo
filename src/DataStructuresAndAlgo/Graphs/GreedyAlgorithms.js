"use strict";
// Greedy algorithms
Object.defineProperty(exports, "__esModule", { value: true });
exports.backpackWorths = exports.backpack = void 0;
//Разберем этот код подробнее. Сначала мы видим функцию backpack(), внутри которой мы реализуем bruteforce() — рекурсивную функцию перебора.
//В коде мы обращаемся к двум внешним переменным:
//worths — массив ценностей
// seen — множество просмотренных ценностей
const backpack = (worths, maxWeight) => {
    const seen = new Set();
    const result = { names: [], summPrice: 0.0, sumWeight: 0 };
    //В качестве параметров мы передаем:
    //sumPrice — общая цена просмотренных ценностей
    const brutforce = (sumPrice, sumWeight) => {
        let isLeaf = true;
        for (const worth of worths) {
            //Можно было бы перебирать ценности в множестве seen, но это слишком накладно для каждого шага рекурсии.
            //Поэтому мы перебираем ценности в цикле for. Если предмет уже просмотрен, мы сразу переходим к следующему предмету:
            if (seen.has(worth)) {
                continue;
            }
            //Если возникает перевес, мы также переходим к следующему предмету:
            if (worth.weight + sumWeight > maxWeight) {
                continue;
            }
            //Мы выполняем рекурсивные вызовы, пока мы не заполнили весь рюкзак и не достигли вершины-листа в нашем графе.
            // Как и в дереве, листом в графе называется вершина, из которой больше некуда идти:
            seen.add(worth);
            brutforce(sumPrice + worth.price, sumWeight + worth.weight);
            seen.delete(worth);
            isLeaf = false;
        }
        //Представим, что мы больше не можем положить в рюкзак ни одного предмета.
        //Это значит, что мы достигли вершины-листа. Флаг isLeaf остается равным true:
        if (isLeaf && sumPrice >= result.summPrice) {
            //Если мы достигли листа и нашли новый лучший результат, сохраняем его в полях переменной result.
            result.summPrice = sumPrice;
            result.sumWeight = sumWeight;
            result.names = Array.from(seen.values()).map((worth) => worth.name);
        }
    };
    brutforce(0.0, 0.0);
    return result;
};
exports.backpack = backpack;
exports.backpackWorths = [
    { name: "Корона", weight: 1.5, price: 150000 },
    { name: "Кувшинчик", weight: 4, price: 60000 },
    { name: "Кувшин", weight: 8, price: 80000 },
    { name: "Шкатулка", weight: 2, price: 40000 },
    { name: "Сундучок", weight: 8, price: 90000 },
    { name: "Сундук", weight: 12, price: 120000 },
    { name: "Диадема", weight: 1.2, price: 70000 },
    { name: "Горшок с монетами", weight: 3, price: 40000 },
    { name: "Сабля", weight: 8, price: 90000 },
    { name: "Скипетр", weight: 6, price: 30000 },
];
//Оценка сложности
//Попробуем оценить алгоритмическую сложность метода перебора. Как и следует из названия, он перебирает все возможные решения,
// добираясь до них через все промежуточные вершины графа.
//Представим, что у нас есть предметы 1, 2, 3, 4. Так будет выглядеть граф, который обходит метод перебора:
//В этом графе есть 16 вершин, в том числе пустая. Рассмотрим, к какому количеству решений ведет разное количество предметов:
//1- Ноль предметов дает 1 решение, то есть Али-Баба уходит с пустым рюкзаком. Так произойдет, если в пещере не найдется предмет весом менее 20 килограмм
//Один предмет дает 2 решения — пустой рюкзак и рюкзак с этим самым предметом
//Два предмета дают 4 решения — пустой рюкзак, рюкзак с первым предметом, рюкзак со вторым и с двумя предметами сразу. Отметим, что 2 * 2 = 4
//Три предмета дают 8 решений
//Четыре предмета дают 16 решений
//Как мы видим, каждый новый предмет удваивает количество вершин. Поэтому метод перебора обладает экспоненциальной сложностью O * 2^n
//Это довольно медленный алгоритм. Для десяти предметов он сработает почти мгновенно,
//а для тридцати — займет уже несколько часов. Для шестидесяти предметов задачу решить уже невозможно — не хватит мощности всех компьютеров на Земле.
//Жадный алгоритм
//Как отказаться от перебора предметов на каждом шаге рекурсии? Один из подходов заключается в том,
//чтобы всякий раз выбирать самый ценный предмет. Работающие по этому принципу алгоритмы называются жадными.
//Чтобы жадный алгоритм выбирал самые ценные предметы, нужно сравнивать не абсолютную,
//а удельную стоимость — то есть стоимость одного килограмма. Как и метод перебора, жадный алгоритм рекурсивно двигается по неявному графу,
//но на каждом шаге он выбирает одну ветвь — с наибольшей удельной стоимостью.
// /Без предварительной сортировки поиск максимума обладает линейной сложностью.
//Другими словами, в худшем случае нам придется перебрать все предметы в пещере. Итого, временная сложность жадного алгоритма равна O * (n * n)
//или O * n^2.
//К сожалению, жадный алгоритм не всегда находит оптимальное решение. Для примера представим, что нам нужно выбрать из двух вариантов:
//2 короны, каждая весит по 1 килограмму и стоит по 80 тысяч долларов
//1 сундук, который весит 20 килограмм и стоит 500 тысяч долларов
//Удельная стоимость корон выше, но сундук выгоднее, поэтому стоит забрать именно его. Жадный алгоритм не учтет такой вариант.
//Для некоторых задач жадный алгоритм дает самое быстрое и эффективное решение.
//Например, в большинстве стран вендинговые автоматы выдают сдачу наименьшим числом монет именно за счет жадного алгоритма.
//В таких автоматах применяется сложная математика, которая выходит за пределы данного курса.
// Если вам интересно изучить эту тему подробнее, можете почитать статью Canonical Coin Systems for Change-Making Problems.
