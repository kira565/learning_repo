"use strict";
// Поиск циклов и матрица смежности
// https://ru.hexlet.io/courses/algorithms-graphs/lessons/cycle-search-adjacency-matrix/theory_unit
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCycleGraph = void 0;
// Let look on simple example. Dependencies in your developepment project
// In our projects we usually have a lot of dependecies
// for example if packacke A imporst package B, we would say: A depends on b
// To build our project we need to load and compile all packages in right order
// If A depends on B, 1st we need to load package B and then A
// In summary, all packages form a difficult Graph of dependencies
// Similar structure of dependencies is very common. For example
// like this we can describe connections between classes
// it calls Dependency Injection !
// But there is a problem, very often programmers dont specify whole graph and they only
// descrive dependencies of current node
// This can lead to cyclical dependency
// In such graph we cannot determine right order of package compilation
// To handle this mistake, there are such instruments like Injection Libraries and bundler systems
// Matrix of adjacecency  Матрица смежности
// Матрица смежности - еще одна структура данных которую применяют при работе с графами
// Все вершины графа мы храним в массиве
// [0,1,2,3,4,5,6]
// Вместе с массивом вершин мы двумерный массив - матрицу смежности n x n где n количество вершин ;(высоат и ширина равна количеству вершин)
// Есть речь идет об обычном невзвешенном графе, элементами массива будут:
// либо тру фолс либо 1 0
// На графе вершина 6 связана с вершиной 2 — записываем true в строку 6 и столбец 2
// Перебирая элементы строки, мы можем найти все связанные вершины.
//Во взвешенном графе вместо булевых значений мы можем хранить числа: если вершины не связаны - null, если связаны число обозначающее вес графа
//Матрица смежности подходит для хранения ориентированных графов.
//Для хранения неориентированных графов программисты используют небольшой трюк, делая матрицу симметричной.
// Для примера представим, что мы хотим связать вершины n и m . В этом случае мы записываем true два раза:
// В столбец n и строку m
// В Столбец m и строку n
//Так мы получаем двустороннюю связь.
// ## Поиск цикла
//Обычно нам надо убедиться, что в графе нет циклов. Поэтому мы пытаемся найти хотя бы один любой цикл.
//Если нам это удается, то мы подсказываем пользователю, из каких вершин он состоит.
//Оказывается, для поиска циклов не надо изобретать нового алгоритма — можно адаптировать обход графа в глубину
//При обходе мы будем помечать посещенные вершины. В реальной программе каждой вершине будет приписан числовой код,
//но при объяснении алгоритма принято говорить о «перекрашивании» вершин.
//Попробуем найти цикл в таком небольшом графе:
//Начинать можно с любой вершины. Мы начнем с вершины 0, которой соответствует верхняя строка в матрице.
//  перекрашиваем ее в серый - значит мы начали с ней работать
// ищем в первой строке связанные вершины они помечаны тру
// Видим, что вершина 0 связана со вторым элементом строки — вершиной 1. Начинаем работать с ней и также перекрашиваем ее в серый цвет:
// Чтобы обнаружить связанные вершины, рассмотрим вторую строку сверху. Она соответствует вершине 1. Похожим образом продолжаем перекрашивать вершины. Следующие на очереди —  2 и 3:
//Из вершины 3 двигаться некуда. Мы завершаем ее обработку, перекрашиваем в черный цвет и возвращаемся в вершину 2.
//У второй вершины есть еще одна необработанная вершина — 4 . Перекрашиваем ее в серый цвет:
//У вершины 4 также нет связанный вершин. Завершаем ее обработку, перекрашиваем в черный цвет, снова возвращаемся в вершину 2.
// Теперь и у вершины 2 обработаны все соседи — значит, ее обработка также завершена. Перекрашиваем ее в черный цвет и возвращаемся в вершину 1:
//У вершины 1 есть следующая необработанная вершина — это 5.
//В свою очередь у вершины 5 есть необработанная вершина 6:
//Вершина 6 связана с вершиной 0, которая окрашена в серый цвет. Это значит, что мы обнаружили цикл.
//Далее нужно разобраться, какие вершины входят в цикл. Для этого мы возвращаемся назад, пока не встретим вершину 0.
//Так мы выясним, что в нашем примере в цикл попадают вершины 6, 5, 1 и 0.
//Если мы встречаем черную вершину, это означает, что цикл в нашем графе есть, но он не опасен. Двигаясь по стрелкам, мы не попадаем в замкнутый круг:
//Двигаясь по стрелкам, ромб слева можно обойти без зацикливания, а ромб справа — нет. Другими словами, встречая черную вершину, мы должны ее пропускать.
//Черная вершина означает, что мы встретили уже обработанную область графа без циклов.
class Vertex {
    value;
    adjacesVertices;
    constructor(val) {
        this.value = val;
        this.adjacesVertices = [];
    }
}
// ### Реализация
class Graph {
    vertices;
    size;
    edges;
    // Как и в прошлых уроках, для работы с графом сделаем класс Graph. В конструкторе мы будем получать массив значений
    //в вершинах графа. Размер массива сохраним в поле size для последующего использования. Также сразу создадим квадратную матрицу смежности,
    // заполним ее значением false:
    constructor(vertices) {
        this.vertices = vertices;
        this.size = vertices.length;
        this.edges = Array.from({ length: this.size }, () => Array(this.size).fill(false));
    }
    //Далее мы создаем связь. По сути, это нахождение элемента в матрице и присвоение ему значения true:
    addEdge(val1, val2) {
        const row = this.vertices.indexOf(val1);
        const column = this.vertices.indexOf(val2);
        this.edges[row][column] = true;
    }
    // Функция возвращает массив вершин, образующих либо цикл, либо значение null при отсутствии циклов.
    findCycle() {
        //Для поиска циклов нам потребуются константы, чтобы обозначать белый, серый и черный цвет вершин, а также массив цветов всех вершин.
        // В начале работы алгоритма все вершины белые:
        const WHITE = 0;
        const GRAY = 1;
        const BLACK = 2;
        const colors = Array(this.size).fill(WHITE);
        // Основная работа делается во внутренней рекурсивной функции visit(). В качестве параметра она получает порядковый номер вершины.
        //Так как нумерация начинается с нуля, первой вершине соответствует номер 0.
        const visit = (i) => {
            //В массиве colors функция выясняет цвет вершины. Если вершина черная, функция сразу прекращает свою работу.
            if (colors[i] === BLACK) {
                return null;
            }
            // Если вершина серая, функция также прекращает работу, но в качестве результата возвращает пустой массив:
            if (colors[i] === GRAY) {
                return [];
            }
            //В середине мы обрабатываем текущую вершину. Перекрашиваем ее в серый цвет, а после обработки всех связанных вершин — в черный:
            colors[i] = GRAY;
            // Обработка связанных вершин заключается в поочередном рекурсивном вызове функции visit(). Если во время очередного вызова функция
            // возвращает массив, это значит, что мы нашли цикл. Добавляем в массив текущую вершину и возвращаем новое значение.
            for (let j = 0; j < this.size; j++) {
                if (this.edges[i][j]) {
                    const result = visit(j);
                    if (Array.isArray(result)) {
                        return [...result, this.vertices[i]];
                    }
                }
            }
            colors[i] = BLACK;
            return null;
        };
        return visit(0);
    }
}
exports.findCycleGraph = new Graph(["0", "1", "2", "3", "4", "5", "6"]);
exports.findCycleGraph.addEdge("0", "1");
exports.findCycleGraph.addEdge("1", "2");
exports.findCycleGraph.addEdge("1", "5");
exports.findCycleGraph.addEdge("2", "3");
exports.findCycleGraph.addEdge("2", "4");
exports.findCycleGraph.addEdge("5", "6");
exports.findCycleGraph.addEdge("6", "0");
