# Graphs Algorithms

In the beginning, graphs were usually used in Mathematics
But now they are also used in programming in a wide specter of different tasks:

1. Creating of schedules
2. Filling containers
3. Work with computer graphics
4. Search for cheap flight tickets
5. Building routes

## What is Graph

Were explained when Leonard Einer was trying to solve one issue:
Visiting every bridge in Königsberg with condition, that 1 bridge cannot be visited twice

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjU2ZTcwZTBmNTJkMmJlOTI4ZDI5ZDk1M2UyZThmMzA2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=0761b2b952dd47760058f10c2d04fddaae72c5fee8e92d5882d45bfa15e26764)

He made 4 points in this map
![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjA1NjY1YzRlMzg4MjkyM2YxYTFiZTY0Y2RjNGEwZTg1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f596c3ffdc197f68db7bfd77b27db8703e99f112ddc7556e9d60ae0637feacc6)

We can actually remove map now

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjFkZmQwNTc3MzQzNGE5ZmIzNTUzN2JmYjg3NjE5MjcyLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=fb4683abbf462ea3df8c9cb2a0c8d7c415ccceb71e6205f3af4b7565fbeb68de)

Because he made representation of issue lot easier, Eiler approved,
that such route is not exists, moreover he made a rule,
which helps to determine if such route is exists.

In that way Eiler developed a method, which allows making
easier issues from hard. Pictures like above, they started to
call Graphs.
Points - Graph vertexes
And connecting arcs - graph edges

Фигуры, подобные рисунку Эйлера, стали называть графами. Точки называются вершинами графа, а соединяющие их дуги — ребрами.

There is a following pattern, that Eiler developed:

1. If Graph vertex has the even number of edges, it means
   we can complete it having visited 1 vertex exact 1 time
   Если из вершины выходит четное количество ребер, то ее можно «пройти», побывав на каждом ребре ровно один раз

2. If the count of vertexes is odd, it means we can link between each other only 2 odd vertexes.
   Если же ребер нечетное число, то между собой можно связать только две нечетных вершины

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjYzY2JlNjk5OTU3ZDk2OWJkMTJiNmM0MWQwNzI3M2Y4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=3d0839495a050edfb49b1f08369a4dd4ebe5a4d1ab6a787474e9b42f503f7e19)

Like that, Einer made a strict Rule:

It is allowed to visit all vertexes of graph, by passing every
edge only once, but only when graph has only 2 odd vertexes,
or it doesn't have it at all.
Можно посетить все вершины графа, пройдя по каждому ребру ровно один раз, но только в том случае, если у графа только две нечетные вершины или вообще нет нечетных вершин

According to this rule, it is impossible to cross Königsberg bridges
like that, because they form graph with 4 odd vertexes.

## Another graphs question

Одна из распространенных задач с графами — это выдача купюр.

Обычно банкоматы стараются выдать сумму наименьшим числом банкнот. Если вы попросили 5000 рублей, банкомат выдаст 5000 рублей одной купюрой. Если такой купюры нет, то банкомат выдаст 2000, 2000 и 1000 рублей. Существует быстрый алгоритм, который всегда оптимально решает эту задачу.

То же самое работает и в логистике. Например, при перевозке контейнеров их заполняют ящиками стандартных размеров. Ящики нужно разместить как можно плотнее, чтобы обойтись минимальным числом контейнеров. Графы позволяют решить и эту задачу.

Еще один пример — текстовые редакторы. Они не только опознают слова с ошибками, но и предлагают варианты замены. Очень непросто найти в словаре несколько слов, похожих на ошибочное, но графы могут разобраться и с этим.

В целом, задачи на графах встречаются в самых разных областях. Но есть одна проблема — их не всегда легко опознать.

Поэтому в этом курсе мы затронем задачи, которые на первый взгляд вообще не имеют отношения к графам.

Например, к таким задачам относятся:

Задача коммивояжера
Задача о рюкзаке

Они заметно отличаются по формулировке, но при этом решаются с помощью одних и тех же алгоритмов.

## Accuracy and performance

Graphs - field of programming where we use approximate solutions
instead of exact ones.

The thing is that exact graph algorithms are too slow,
and they cannot be used on practice.

## Practical usage of Graphs

Вы уже знаете, что граф — это фигура, состоящая из вершин и соединяющих их ребер. С помощью графов решают многие важные классы задач.

# Select Subway Route

Представьте себе схему метро крупного города: скорее всего, в центре будут пересекаться несколько разных веток. Из-за этого получается, что проехать между станциями можно разными способами.
Например, в московском метро от станции «Фрунзенская» до станции «Полянка» можно доехать двумя способами:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjA1YWUyYWE2NTMwNDVkZmIzOWU0NjY3MzZiMTA2ZTVhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=52e3f91fdc84d34182a5f8f3adbfadce5c7216331a59ce3af76cc44e6958a552)

Попробуем определить, какой из этих маршрутов короче. Чтобы посчитать общее время в пути, нужно знать, сколько времени занимает проезд между соседними станциями и сколько времени занимает переход.

По сути, карта метро — это граф. Немного дорисуем его, чтобы обозначить переходы с ветки на ветку. На новом рисунке проставим время в минутах рядом с каждым ребром — перегоном между соседними станциями или переходом:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImMwODQ5N2JhMjQyYmIxMmE1MDNmMWViODhhMGUzYTRlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=0552b60c722b5a23bf9bf0359a1fd58c86c1021eac9f655b4150c1d5c1d3718f)

Теперь можно вычислить полное время на каждом маршруте и выбрать самый короткий. Решение выглядит обманчиво простым. Люди интуитивно отбрасывают заведомо плохие варианты и сразу видят два подходящих маршрута. У компьютера интуиции нет — он переберет все маршруты, которых в действительности гораздо больше двух.

Задачи такого рода в программировании относят к классу «задачи о кратчайшем пути». Число, приписанное каждому ребру, называют весом ребра, а сам граф называют взвешенным.

Неочевидно, почему используют слово «вес», а не «длительность пути». Этому есть объяснение. За названием «взвешенные графы» скрываются разные задачи, решаемые одним и тем же способом. Для некоторых задач числа обозначают время, для других — расстояния, для третьих — денежные суммы, для четвертых — вес.

Этот термин широко используется в математике — там есть весовые коэффициенты или весовая функция. Так что программисты получили этот термин в наследство от математиков.

## Строим маршрут по автомобильным дорогам

Рассмотрим еще одну задачу — построение автомобильного маршрута. Для начала нужно определиться с ребрами и вершинами:

Ребрами будут считаться сами дороги
Вершинами — развилки и пересечения дорог

Здесь мы сталкиваемся с одной сложностью, которой не было в задаче с метро. В отличие от метро, автомобильные дороги могут быть с односторонним движением. Рисуя граф, мы должны учитывать эту особенность.

Граф движения по городу может выглядеть так, как показано на картинке ниже. Голубым цветом нарисованы проспекты, а зеленом — односторонняя часть пути во дворах:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjdlZWJlYmQwMDgzNmY1Y2RiMzZhMGJmYjBhOWVjZmNmLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d3c537bd9d47e50c4dc5aaab84b11b5a2508c8af0456adfec141df513f4e6fc8)

На этот граф мы добавили стрелки, которые показывают направление движения:

Если дорога односторонняя, мы рисуем ребро со стрелкой

Если дорога двухсторонняя, мы рисуем два ребра с противоположными стрелками

Если у ребер графа задано направление, такой граф называют направленным или ориентированным. Часто название «ориентированный граф» сокращают до «орграфа».

Обратите внимание, что граф автомобильных дорог не только ориентированный, но и взвешенный — ведь нам нужно находить по нему оптимальные маршруты. В отличие от метро, на автомобильных дорогах бывают пробки. Поэтому мы не можем заранее присвоить ребрам точный вес — придется обозначать его как время проезда без учета пробок.

## Выбираемся из лабиринта

Иногда нам не нужно выискивать идеальный маршрут — достаточно выяснить, можно ли его построить. Для примера представьте, что нам надо выбраться из лабиринта:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImYxMDY5YzE1Y2ViZWJkNjI4ZDExZWFjM2JjOWNiZTM0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=860dcc7ee6dea6a16320052f9de2f1d62e6fcc007437a10ead9f57073ae7dbd3)

В таком случае мы согласимся на любой путь и не будем уточнять, если ли пути покороче.

Есть несколько стратегий выхода из лабиринта. Например, есть правило правой руки, которое предлагает такую стратегию:

Мы кладем правую руку на стену и начинаем идти по лабиринту
Если мы пришли к развилке, всегда выбираем правый путь
Если мы пришли в тупик, возвращаемся к последней развилке и идем в следующий по счету коридор
Если все коридоры закончились тупиком, возвращаемся к предпоследней развилке и продолжаем обход справа налево

Конечно, коридоры можно обходить и слева направо, тогда речь будет идти о правиле левой руки — оно работает абсолютно так же. Здесь важно придерживаться всегда одной стороны, не смешивая повороты направо и налево.

Как и в случае с автомобильной картой, вершинами графа будут только места развилок и тупики. Посмотрим, как будет выглядеть маршрут по лабиринту:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImMzNjc5YjczMjRjZDY2MDhlMTRjZTQ2MzdhMzUzMjEzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a01c149b0271feb0f11b3d9b640634804429ae5635850e8cc2a90ef1c9b151ca)

Рассмотрим этот рисунок подробнее:

Красными линиями обозначены ребра графа

Кружками обозначены вершины

Направление обхода графа показано синим цветом

Стратегия предполагает, что мы пытаемся пройти как можно глубже, а если попадаем в тупик, возвращаемся назад. На рисунке это тоже видно — синяя линия часто идет в двух направлениях.

Такой способ движения по графу называется обходом в глубину. Этот алгоритм применяется для поиска вершины с определенными свойствами, поэтому часто употребляют похожий термин — «поиск в глубину». В профессиональной литературе вы можете встретить аббревиатуру DFS — depth first search, то есть «поиск сначала в глубину».

Этот алгоритм прекрасно работает, если в лабиринте нет замкнутых коридоров или петель. Если мы попадем на петлю, мы можем вечно ходить по одному и тому же коридору, как показано на рисунке:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQyMmVkMjAwYjU2Yzk5OTI1NjhkMTk1NTYwNTIyNDQ4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d10ecb3bc63bfe00eff57a4c623abfd3bca7cea40ad4c1ebbf5019b0bef5bbb8)

Если мы нарисуем граф для такого лабиринта, мы обнаружим такую же петлю. Графы с петлями называются циклическими и требуют осторожности при обходе:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjliZjFhNWMxMGFlYmIyYzgxN2EwZmFiYzEwNzZkYWZhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=bc278110fe1ba431df3a9602349f1f150ce99c6919a1fcf3a029b8c528b37122)

Обходя лабиринт с петлями, можно помечать посещенные развилки мелом. Встретив пометку, мы узнаем, что попали в цикл. Действовать в этом случае надо так же, как и в тупике — развернуться и идти назад.

## Обходим препятствия

В ролевых и стратегических играх пользователь управляет игровыми юнитами. Например, он может отправить боевой или строительный юнит на другой конец карты. Как правило, на карте встречаются препятствия — непроходимые горы и озера.

Игровая карта может выглядеть так:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjJlMjM0YjFlZTdmYTc1MWVkNTNmYzU3ZTM4Y2JjYmU3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ccc14b576b37d283220f2fba2725424353db13caf3b868c9aacf458b871fdaca)

Двигаясь по карте, юниты уверенно огибают преграды и достигают цели за кратчайшее время. Разберемся, как это работает.

Как и в предыдущих задачах, мы сначала решаем, что будет считаться ребрами и вершинами графа. В компьютерных играх вершины размещают в клетках карты. Ребра связывают соседние пустые клетки, в которых нет гор или озер.

Представим, что нам надо добраться из вершины Н в вершину К:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjBiOWM5NjVhODdjNGExN2Y5YzYxOWUwY2E5YzUwNDFiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=93f448e4df13ea16d96826279dd9d9f25470ccbd8d1db650f8dcaab9fdd010f4)

Поиск в глубину поможет найти дорогу, но если на карте много поворотов и узких проходов, эффективнее будет другой алгоритм. Он называется волновым, потому что напоминает волны, кругами расходящиеся на воде от брошенного камня:

Сначала мы проверяем соседей начальной вершины, затем — соседей соседей, и так далее, каждый раз удаляясь от начальной вершины на один шаг. В какой-то момент очередной круг доберется до конечной вершины. Это будет означать, что путь найден:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImY0NmVhM2JjNDAyNDFmMjdmNWM3YzlmNmU0MDBlMDc2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=61d63eeaaec8f8e0a4890909bab1602ed0291b00a1986191ea8d5a0caf9d2273)

Другое название этого алгоритма — поиск в ширину или BFS, breadth first search. Он позволяет найти маршрут с наименьшим количеством ребер. Впрочем, у него гораздо больше применений. В частности, одна из его модификаций позволяет закрашивать на изображениях замкнутые области произвольной формы.

Может показаться, что задачи на графах касаются в первую очередь карт или каких-то картинок, но это не так. Далее мы узнаем, как графы применяют при решении экономических и логистических задач.

## Считаем сдачу

Одна из задач, которую решает программное обеспечение банкоматов и вендинговых аппаратов — выдача сдачи. Как правило, автоматы пытаются выдать сдачу наименьшим количеством банкнот или монет.

Номиналы монет подбираются так, чтобы ими можно было выдать любую сумму. Например, сдачу в 8 рублей можно выдать тремя монетами: 5 рублей, 2 рубля и 1 рубль.

Чтобы посчитать сдачу, можно использовать простой алгоритм выбора монет:

Пока можем, набираем сумму самыми крупными монетами
Затем переходим к следующим по номиналу монетам, и так далее

Проблема в том, что иногда в автомате заканчиваются монеты определенного номинала. Отсутствие двухрублевых монет не скажется на работе алгоритма: он выберет одну пятирублевую монету и три однорублевых.

Но если в автомате закончатся рублевые монеты, алгоритм не сможет вернуть сдачу в 8 рублей. Сначала он выберет монету в 5 рублей, потом монету в 2 рубля, а дальше начинаются сложности — надо выбрать монету в 1 рубль, а они закончились.

Даже в этом случае задача может быть решена — сдачу можно выдать четырьмя монетами по 2 рубля. Проблема в том, что простой алгоритм этот вариант не найдет.

Более сложный алгоритм работает на графах. Это может показаться странным, потому что не совсем очевидно, как они сюда относятся:

![alt text](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImE3OGM4Mjk4NjViNDE0ZWJkYTYwZTM1NWY3MGVhNmQxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9028baad5e270c265c368292130fd162bcfb656d57aaee869869d9c0708568f2)

На рисунке мы видим, что каждый узел графа может содержать набор монет. Двигаясь по стрелкам, мы добавляем к набору одну новую монету. Мы начинаем с пустого узла, в котором нет ни одной монеты. Далее мы ищем узлы, где достигается нужная сумма в 8 рублей.

У нас нет карты, которая стала бы основой для графа, потому что мы не храним все узлы графа. Вместо этого, можно генерировать новые соседние узлы по мере надобности, следуя простым правилам.

Подобные графы часто встречаются в программировании, они называются неявными. Неявный граф не требует хранения своих узлов — узлы можно вывести или вычислить.

Хорошим кандидатом для решения задачи о монетах будет алгоритм поиска в ширину. Мы продвигаемся во всех направлениях от пустого узла, в поисках узлов, содержащих сумму 8 рублей.

К сожалению, этот алгоритм не очень эффективен. Нам надо дать сдачу наименьшим числом монет, поэтому мы можем всегда начинать с монеты самого крупного номинала. Это решение похоже на то, которые мы рассматривали в начале. Разница только в том, что у нас остается возможность найти правильный ответ, даже если каких-то номиналов не хватает.

Такой поиск похож на поиск в ширину, у которого есть предпочтительное направление. Мы можем использовать его, потому что у нас есть дополнительная информация о задаче.

При работе с графами программисты часто используют подобную информацию для того, чтобы ускорить алгоритм. Такие модификации называются информированными алгоритмами. Классические алгоритмы без дополнительной информации называют неинформированными.
