// Greedy algorithms

// in programming there are issues which are not related to graphs, in first look
// But they solved exactly with graphs

//  Одна из таких задач про швейную фабрику где роботы вырезают детали по выкройкам из больших кусков ткани
// Для экономии ткани важно оставлять как можно меньше обрезков

// Чтобы решить такую задачу можно использовать неявное представление графов
// Действуя методом полного перебора можно найти все варианты размещения деталей чтобы
// площадь обрезков была как можно меньше

// Рассмотрим еще один пример котоырй встречается при программированнии банкоматов
// или вендинговых автоматов гду требуется выдать сумму наименьшим количеством монет или банкнот
// Представим что нужно выдать 11 рублей Эффективнее всего выдавать две монеты 10 рублей и 1
// Но в автомате может не оказаться десятирублевых и тогда простой алгоритм не найдет
// альтернативный вариант одна монета в 5 рублей и три монеты в 2 рубля
// Как и в случае с раскроем все возможные решения можно найти только перебором

// Перечисленные задачи не похожи друг на друга но их принято относить к одному классу
// потому что решаются они одинаково
// Название всему классу дала задача о рюкзаке и одна из ее формуоировок звучит так

//Попав в пещеру к разбойникам, Али-баба решил забрать как можно больше ценностей. У него есть рюкзак, рассчитанный на 20 килограмм.
// Нужно выбрать самые ценные предметы так, чтобы они уместились в рюкзак

// В чем сложность задачи ? Отобрать самое ценное не так уж сложно но есть и второе ограничение - вес предмета
// Без перебора мы можем выбрать самый дорогой предмет в комнате - двадцатикиллограмовый сундук
// Но если проверить все варианты перебором то может оказаться что два десятикилограммовых кувшина в сумме стоят больше
// Тогда нужно унести два кувшина а не один сундук

// В целом в задаче о рюкзаке речь идет о множестве предметов из которого мы должны выбрать оптимальное подмножество
// с учетом ограничений. В задаче о раскрое мы минимализировали площадь обрезков а при выдаче сдачи - колчество монет
// В задаче о рюкзаке мы максимизируем стоимость предметов. Другими словами во все хзадачах о рюкзаке речь идет о множестве
// наборе ограничений и оптимальном подмножестве

// Метод перебора

// Это простейший способ решения задач на графе
// В случае задач о рюкзаке граф обычно представлен неявно
// При этом алгоритм работает рекурсивно Это значит что мы начинаем с пустого рюкзака и на каждом шаге рекурсии пытаемся
// положить в него один из оставшихся предметов. Если максимальынй вес не превышен то мы помещаем предмет в рюкзак и поускаемся на след
// уровень рекурсии

// Рекурсия завершается когда вес рюкзака превышен. В этот момент мы фиксируем текущее состояние рюкзака - одно из возможных решений
// При этом ненадо хранить все найденные решения достаточно хранить самое дорогое

// Второй повод для завершения рекурсии - закончились предметы - то есть в рюкзак поместились все предметы но так почти не бывает

// Взглянем на реализацию такого алгоритма
interface Worth {
  price: number;
  weight: number;
  name: string;
}
interface Result {
  names: string[];
  summPrice: number;
  sumWeight: number;
}
//Разберем этот код подробнее. Сначала мы видим функцию backpack(), внутри которой мы реализуем bruteforce() — рекурсивную функцию перебора.
//В коде мы обращаемся к двум внешним переменным:
//worths — массив ценностей
// seen — множество просмотренных ценностей

export const backpack = (worths: Worth[], maxWeight: number) => {
  const seen = new Set();
  const result: Result = { names: [], summPrice: 0.0, sumWeight: 0 };
  //В качестве параметров мы передаем:
  //sumPrice — общая цена просмотренных ценностей
  const brutforce = (sumPrice: number, sumWeight: number) => {
    let isLeaf = true;
    for (const worth of worths) {
      //Можно было бы перебирать ценности в множестве seen, но это слишком накладно для каждого шага рекурсии.
      //Поэтому мы перебираем ценности в цикле for. Если предмет уже просмотрен, мы сразу переходим к следующему предмету:
      if (seen.has(worth)) {
        continue;
      }
      //Если возникает перевес, мы также переходим к следующему предмету:
      if (worth.weight + sumWeight > maxWeight) {
        continue;
      }
      //Мы выполняем рекурсивные вызовы, пока мы не заполнили весь рюкзак и не достигли вершины-листа в нашем графе.
      // Как и в дереве, листом в графе называется вершина, из которой больше некуда идти:
      seen.add(worth);
      brutforce(sumPrice + worth.price, sumWeight + worth.weight);
      seen.delete(worth);
      isLeaf = false;
    }
    //Представим, что мы больше не можем положить в рюкзак ни одного предмета.
    //Это значит, что мы достигли вершины-листа. Флаг isLeaf остается равным true:
    if (isLeaf && sumPrice >= result.summPrice) {
      //Если мы достигли листа и нашли новый лучший результат, сохраняем его в полях переменной result.
      result.summPrice = sumPrice;
      result.sumWeight = sumWeight;
      result.names = (Array.from(seen.values()) as Worth[]).map(
        (worth) => worth.name
      );
    }
  };

  brutforce(0.0, 0.0);
  return result;
};

export const backpackWorths = [
  { name: "Корона", weight: 1.5, price: 150000 },
  { name: "Кувшинчик", weight: 4, price: 60000 },
  { name: "Кувшин", weight: 8, price: 80000 },
  { name: "Шкатулка", weight: 2, price: 40000 },
  { name: "Сундучок", weight: 8, price: 90000 },
  { name: "Сундук", weight: 12, price: 120000 },
  { name: "Диадема", weight: 1.2, price: 70000 },
  { name: "Горшок с монетами", weight: 3, price: 40000 },
  { name: "Сабля", weight: 8, price: 90000 },
  { name: "Скипетр", weight: 6, price: 30000 },
];

//Оценка сложности
//Попробуем оценить алгоритмическую сложность метода перебора. Как и следует из названия, он перебирает все возможные решения,
// добираясь до них через все промежуточные вершины графа.
//Представим, что у нас есть предметы 1, 2, 3, 4. Так будет выглядеть граф, который обходит метод перебора:
//В этом графе есть 16 вершин, в том числе пустая. Рассмотрим, к какому количеству решений ведет разное количество предметов:

//1- Ноль предметов дает 1 решение, то есть Али-Баба уходит с пустым рюкзаком. Так произойдет, если в пещере не найдется предмет весом менее 20 килограмм
//Один предмет дает 2 решения — пустой рюкзак и рюкзак с этим самым предметом
//Два предмета дают 4 решения — пустой рюкзак, рюкзак с первым предметом, рюкзак со вторым и с двумя предметами сразу. Отметим, что 2 * 2 = 4
//Три предмета дают 8 решений
//Четыре предмета дают 16 решений

//Как мы видим, каждый новый предмет удваивает количество вершин. Поэтому метод перебора обладает экспоненциальной сложностью O * 2^n
//Это довольно медленный алгоритм. Для десяти предметов он сработает почти мгновенно,
//а для тридцати — займет уже несколько часов. Для шестидесяти предметов задачу решить уже невозможно — не хватит мощности всех компьютеров на Земле.

//Жадный алгоритм
//Как отказаться от перебора предметов на каждом шаге рекурсии? Один из подходов заключается в том,
//чтобы всякий раз выбирать самый ценный предмет. Работающие по этому принципу алгоритмы называются жадными.

//Чтобы жадный алгоритм выбирал самые ценные предметы, нужно сравнивать не абсолютную,
//а удельную стоимость — то есть стоимость одного килограмма. Как и метод перебора, жадный алгоритм рекурсивно двигается по неявному графу,
//но на каждом шаге он выбирает одну ветвь — с наибольшей удельной стоимостью.

// /Без предварительной сортировки поиск максимума обладает линейной сложностью.
//Другими словами, в худшем случае нам придется перебрать все предметы в пещере. Итого, временная сложность жадного алгоритма равна O * (n * n)
//или O * n^2.

//К сожалению, жадный алгоритм не всегда находит оптимальное решение. Для примера представим, что нам нужно выбрать из двух вариантов:

//2 короны, каждая весит по 1 килограмму и стоит по 80 тысяч долларов
//1 сундук, который весит 20 килограмм и стоит 500 тысяч долларов

//Удельная стоимость корон выше, но сундук выгоднее, поэтому стоит забрать именно его. Жадный алгоритм не учтет такой вариант.
//Для некоторых задач жадный алгоритм дает самое быстрое и эффективное решение.
//Например, в большинстве стран вендинговые автоматы выдают сдачу наименьшим числом монет именно за счет жадного алгоритма.

//В таких автоматах применяется сложная математика, которая выходит за пределы данного курса.
// Если вам интересно изучить эту тему подробнее, можете почитать статью Canonical Coin Systems for Change-Making Problems.
